!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r():"function"==typeof define&&define.amd?define(r):(e="undefined"!=typeof globalThis?globalThis:e||self).Kensho=r()}(this,(function(){"use strict";const e=new Map,r={add(r,t){if("string"!=typeof r)throw new Error('The argument "name" must be a string.');if(""===r)throw new Error("Empty string are not accepted.");if("function"!=typeof t)throw new Error('The argument "rule" must be a function.');if(e.get(r))throw new Error(`The "${r}" rule already exist.`);e.set(r,t)},remove(r){if("string"!=typeof r)throw new Error('The argument "name" must be a string.');if(""===r)throw new Error("Empty string are not accepted.");if(!e.get(r))throw new Error(`The "${r}" rule isn't existed.`);e.delete(r)},get(r){if("string"!=typeof r)throw new Error('The argument "name" must be a string.');if(""===r)throw new Error("Empty string are not accepted.");const t=e.get(r);if(void 0===t)throw new Error(`The "${r}" rule isn't found.`);return t},book(e){Object.entries(e).forEach((([e,r])=>this.add(e,r)))}},t=new Map,n={add(e,r){if("string"!=typeof e)throw new Error('The argument "name" must be a string.');if(""===e)throw new Error("Empty string are not accepted.");if("function"!=typeof r)throw new Error('The argument "plugin" must be a function.');if(t.get(e))throw new Error(`The "${e}" plugin already exist.`);t.set(e,r)},remove(e){if("string"!=typeof e)throw new Error('The argument "name" must be a string.');if(""===e)throw new Error("Empty string are not accepted.");if(!t.get(e))throw new Error(`The "${e}" plugin isn't existed.`);t.delete(e)},get(e){if("string"!=typeof e)throw new Error('The argument "name" must be a string.');if(""===e)throw new Error("Empty string are not accepted.");const r=t.get(e);if(void 0===r)throw new Error(`The "${e}" plugin isn't found.`);return r},use(e){}},o=new Map,i={add(e,r){if("string"!=typeof e)throw new Error('The argument "name" must be a string.');if(""===e)throw new Error("Empty string are not accepted.");if("function"!=typeof r)throw new Error('The argument "converter" must be a function.');if(o.get(e))throw new Error(`The "${e}" converter already exist.`);o.set(e,r)},remove(e){if("string"!=typeof e)throw new Error('The argument "name" must be a string.');if(""===e)throw new Error("Empty string are not accepted.");if(!o.get(e))throw new Error(`The "${e}" converter isn't existed.`);o.delete(e)},get(e){if("string"!=typeof e)throw new Error('The argument "name" must be a string.');if(""===e)throw new Error("Empty string are not accepted.");const r=o.get(e);if(void 0===r)throw new Error(`The "${e}" converter isn't found.`);return r}};return class{static rule=r;static plugin=n;static converter=i;static validate(e,r,t){return this.rule.get(e)(r,t)}static convert(e,r){"string"==typeof r&&(r=[r]),r.forEach((r=>{e=this.converter.get(r)(e)}));const t=this.validate;return{...this,validate:(r,n)=>t(r,e,n)}}constructor(){}}}));
//# sourceMappingURL=bundle.umd.min.js.map
